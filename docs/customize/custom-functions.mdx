---
title: "Tools"
description: "Extend default agent and write custom action functions to do certain tasks"
icon: "wrench"
mode: "wide"
---

Custom actions are functions *you* provide, that are added to our [default actions](https://github.com/browser-use/browser-use/blob/main/browser_use/controller/service.py) the agent can use to accomplish tasks.
Action functions can request [arbitrary parameters](#action-parameters-via-pydantic-model) that the LLM has to come up with + a fixed set of [framework-provided arguments](#framework-provided-parameters) for browser APIs / `Agent(context=...)` / etc.

<Note>
  Our default set of actions is already quite powerful, the built-in `Controller` provides basics like `go_to_url`, `scroll_down`, `extract_content`, [and more](https://github.com/browser-use/browser-use/blob/main/browser_use/controller/service.py).
</Note>

It's easy to add your own actions to implement additional custom behaviors, integrations with other apps, or performance optimizations.

For examples of custom actions (e.g. uploading files, asking a human-in-the-loop for help, drawing a polygon with the mouse, and more), see [examples/custom-functions](https://github.com/browser-use/browser-use/tree/main/examples/custom-functions).


## Action Function Registration

To register your own custom functions (which can be `sync` or `async`), decorate them with the `@controller.action(...)` decorator. This saves them into the `controller.registry`.

```python
from browser_use import Controller, ActionResult

controller = Controller()

@controller.action('Ask human for help with a question', domains=['example.com'])   # pass allowed_domains= or page_filter= to limit actions to certain pages
def ask_human(question: str) -> ActionResult:
    answer = input(f'{question} > ')
    return ActionResult(extracted_content=f'The human responded with: {answer}', include_in_memory=True)
```

```python
# Then pass your controller to the agent to use it
agent = Agent(
    task='...',
    llm=llm,
    controller=controller,
)
```

<Note>
  Keep your action function names and descriptions short and concise:
  - The LLM chooses between actions to run solely based on the function name and description
  - The LLM decides how to fill action params based on their names, type hints, & defaults
</Note>

---

## Action Parameters

Browser Use supports two patterns for defining action parameters: normal function arguments, or a Pydantic model.

### Function Arguments

For simple actions that don't need default values, you can define the action parameters directly as arguments to the function. This one takes a single string argument, `css_selector`.
When the LLM calls an action, it sees its argument names & types, and will provide values that fit.

```python
@controller.action('Click element')
async def click_element(css_selector: str, browser_session: Browser) -> ActionResult:
    # css_selector is an action param the LLM must provide when calling
    # browser_session is a special framework-provided param to access the browser APIs (see below)
    
    # Get the current CDP session to interact with the browser
    cdp_session = await browser_session.get_or_create_cdp_session()
    
    # Use CDP to evaluate JavaScript and click the element
    await cdp_session.cdp_client.send.Runtime.evaluate(
        params={'expression': f'document.querySelector("{css_selector}").click()'},
        session_id=cdp_session.session_id,
    )
    return ActionResult(extracted_content=f"Clicked element {css_selector}")
```

### Pydantic Model

You can define a pydantic model for the parameters your action expects by setting a `@controller.action(..., param_model=MyParams)`.
This allows you to use optional parameters, default values, `Annotated[...]` types with custom validation, field descriptions, and other features offered by pydantic.

When the agent calls calls your agent function, an instance of your model with the values filled by the LLM will be passed as the argument named `params` to your action function.

Using a pydantic model is helpful because it allows more flexibility and power to enforce the schema of the values the LLM should provide.
The LLM gets the entire pydantic JSON schema for your `param_model`, it will see the function name & description + individual field names, types, descriptions, and default values.


```python
from typing import Annotated
from pydantic import BaseModel, AfterValidator
from browser_use import ActionResult

class MyParams(BaseModel):
    field1: int
    field2: str = 'default value'
    field3: Annotated[str, AfterValidator(lambda s: s.lower())]  # example: enforce always lowercase
    field4: str = Field(default='abc', description='Detailed description for the LLM')

@controller.action('My action', param_model=MyParams)
async def my_action(params: MyParams, browser_session: Browser) -> ActionResult:
    # Get the current CDP session to interact with the browser
    cdp_session = await browser_session.get_or_create_cdp_session()
    
    # Use CDP to type text
    await cdp_session.cdp_client.send.Input.insertText(
        params={'text': params.field2},
        session_id=cdp_session.session_id,
    )
    
    # Get current URL using CDP
    result = await cdp_session.cdp_client.send.Runtime.evaluate(
        params={'expression': 'window.location.href', 'returnByValue': True},
        session_id=cdp_session.session_id,
    )
    current_url = result.get('result', {}).get('value', 'unknown')
    
    return ActionResult(extracted_content=f"Inputted {params} on {current_url}")
```

Any special framework-provided arguments (e.g. `browser_session`) will be passed as separate positional arguments after `params`.

<Important>
To use a `BaseModel` the arg *must* be called `params`. Action function args are matched and filled like named arguments; arg order doesn't matter but names and types do.
</Important>

### Framework-Provided Parameters

These special action parameters are injected by the `Controller` and are passed as extra args to any actions that expect them.

For example, actions that need to interact with the browser should take the `browser_session` argument.

- `browser_session: Browser` - The current browser session with access to CDP for browser interaction
- `context: AgentContext` - Any optional top-level context object passed to the Agent, e.g. `Agent(context=user_provided_obj)`
- `page_extraction_llm: BaseChatModel` - LLM instance used for page content extraction
- `available_file_paths: list[str]` - List of available file paths for upload / processing
- `has_sensitive_data: bool` - Whether the action content contains sensitive data markers (check this to avoid logging sensitive data to terminal by accident)

<Note>
Browser Use has moved from Playwright to Chrome DevTools Protocol (CDP) for browser interaction. The `browser_session` provides access to CDP through `browser_session.agent_focus.cdp_client` or `await browser_session.get_or_create_cdp_session()`. Playwright is only used internally to install the browser binary, but all browser interaction is done via CDP.
</Note>

### Understanding the Browser Session Context

The `Browser` object provides multiple ways to interact with the browser:

#### 1. Direct CDP Access
```python
# Get the current CDP session
cdp_session = await browser_session.get_or_create_cdp_session()

# Execute JavaScript
result = await cdp_session.cdp_client.send.Runtime.evaluate(
    params={'expression': 'document.title', 'returnByValue': True},
    session_id=cdp_session.session_id,
)

# Click at coordinates
await cdp_session.cdp_client.send.Input.dispatchMouseEvent(
    params={
        'type': 'mousePressed',
        'x': 100,
        'y': 200,
        'button': 'left',
        'clickCount': 1,
    },
    session_id=cdp_session.session_id,
)
await cdp_session.cdp_client.send.Input.dispatchMouseEvent(
    params={
        'type': 'mouseReleased',
        'x': 100,
        'y': 200,
        'button': 'left',
    },
    session_id=cdp_session.session_id,
)
```

#### 2. Event-Based Actions
```python
from browser_use.browser.events import ClickElementEvent, TypeTextEvent, NavigateToUrlEvent

# Get a DOM element first
element = await browser_session.get_dom_element_by_index(5)

# Dispatch events through the event bus
click_event = browser_session.event_bus.dispatch(ClickElementEvent(node=element))
await click_event

type_event = browser_session.event_bus.dispatch(TypeTextEvent(node=element, text="Hello"))
await type_event

navigate_event = browser_session.event_bus.dispatch(NavigateToUrlEvent(url="https://example.com"))
await navigate_event
```

#### 3. High-Level Browser Session Methods
```python
# Get current page information
state = await browser_session.get_browser_state_summary()
print(f"Current URL: {state.url}")
print(f"Page title: {state.title}")

# Take a screenshot
screenshot_path = await browser_session.take_screenshot()

# Get page HTML
html = await browser_session.get_page_html()

# Get all open tabs
tabs = await browser_session.get_tabs()
```

#### Example: Action uses the current browser session

```python
from browser_use import Browser, Controller, ActionResult

controller = Controller()

@controller.action('Type keyboard input into a page')
async def input_text_into_page(text: str, browser_session: Browser) -> ActionResult:
    # Get the current CDP session to interact with the browser
    cdp_session = await browser_session.get_or_create_cdp_session()
    
    # Use CDP to type text
    await cdp_session.cdp_client.send.Input.insertText(
        params={'text': text},
        session_id=cdp_session.session_id,
    )
    return ActionResult(extracted_content='Text input completed')
```

#### Example: Action uses browser session for tab management

```python
from browser_use import Browser, Controller, ActionResult
from browser_use.browser.events import NavigateToUrlEvent, SwitchTabEvent

controller = Controller()

@controller.action('Open website')
async def open_website(url: str, browser_session: Browser) -> ActionResult:
    # Get all open tabs
    tabs = await browser_session.get_tabs()
    
    # Check if URL is already open in any tab
    for tab in tabs:
        if tab.url == url:
            # Switch to existing tab using events
            switch_event = browser_session.event_bus.dispatch(SwitchTabEvent(target_id=tab.target_id))
            await switch_event
            return ActionResult(extracted_content=f'Switched to existing tab with url {url}')
    
    # Otherwise, open URL in a new tab using events
    navigate_event = browser_session.event_bus.dispatch(NavigateToUrlEvent(url=url, new_tab=True))
    await navigate_event
    return ActionResult(extracted_content=f'Opened new tab with url {url}')
```


---


## Important Rules

1. **Return an [`ActionResult`](https://github.com/search?q=repo%3Abrowser-use%2Fbrowser-use+%22class+ActionResult%28BaseModel%29%22&type=code)**: All actions should return an `ActionResult | str | None`. The stringified version of the result is passed back to the LLM, and optionally persisted in the long-term memory when `ActionResult(..., include_in_memory=True)`.
2. **Type hints on arguments are required**: They are used to verify that action params don't conflict with special arguments injected by the controller (e.g. `browser_session`)
3. **Actions functions called directly must be passed kwargs**: When calling actions from other actions or python code, you must **pass all parameters as kwargs only**, even though the actions are usually defined using positional args (for the same reasons as [pluggy](https://pluggy.readthedocs.io/en/stable/index.html#calling-hooks)).
    Action arguments are always matched by name and type, **not** positional order, so this helps prevent ambiguity / reordering issues while keeping action signatures short.
    ```python
    @controller.action('Fill in the country form field')
    async def input_country_field(country: str, browser_session: Browser) -> ActionResult:
        await some_action(123, browser_session=browser_session)                                # ❌ not allowed: positional args, use kwarg syntax when calling
        await some_action(abc=123, browser_session=browser_session)                            # ✅ allowed: action params & special kwargs
        await some_other_action(params=OtherAction(abc=123), browser_session=browser_session)  # ✅ allowed: params=model & special kwargs
    ```

```python
# Using Pydantic Model to define action params (recommended)
class PinCodeParams(BaseModel):
    code: int
    retries: int = 3                                               # ✅ supports optional/defaults

@controller.action('...', param_model=PinCodeParams)
async def input_pin_code(params: PinCodeParams, browser_session: Browser): ...   # ✅ special params at the end

# Using function arguments to define action params
async def input_pin_code(code: int, retries: int, browser_session: Browser): ... # ✅ params first, special params second, no defaults
async def input_pin_code(code: int, retries: int=3): ...           # ✅ defaults ok only if no special params needed
async def input_pin_code(code: int, retries: int=3, browser_session: Browser): ... # ❌ Python SyntaxError! not allowed
```


---


## Reusing Custom Actions Across Agents

You can use the same controller for multiple agents.

```python
controller = Controller()

# ... register actions to the controller

agent = Agent(
    task="Go to website X and find the latest news",
    llm=llm,
    controller=controller
)

# Run the agent
await agent.run()

agent2 = Agent(
    task="Go to website Y and find the latest news",
    llm=llm,
    controller=controller
)

await agent2.run()
```

<Note>
  The controller is stateless and can be used to register multiple actions and
  multiple agents.
</Note>



## Exclude functions

If you want to exclude some registered actions and make them unavailable to the agent, you can do:
```python
controller = Controller(exclude_actions=['search_google'])
agent = Agent(controller=controller, ...)
```



@controller.action('Fill out secret_form', allowed_domains=['https://*.example.com'])
def fill_out_form(...) -> ActionResult:
    ... will only be runnable by LLM on pages that match https://*.example.com
```
